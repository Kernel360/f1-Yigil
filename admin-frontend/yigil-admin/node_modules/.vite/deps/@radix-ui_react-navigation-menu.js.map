{
  "version": 3,
  "sources": ["../../@radix-ui/react-use-previous/dist/packages/react/use-previous/src/index.ts", "../../@radix-ui/react-use-previous/dist/packages/react/use-previous/src/usePrevious.tsx", "../../@radix-ui/react-visually-hidden/dist/packages/react/visually-hidden/src/index.ts", "../../@radix-ui/react-visually-hidden/dist/packages/react/visually-hidden/src/VisuallyHidden.tsx", "../../@radix-ui/react-navigation-menu/dist/packages/react/navigation-menu/src/index.ts", "../../@radix-ui/react-navigation-menu/dist/packages/react/navigation-menu/src/NavigationMenu.tsx"],
  "sourcesContent": ["export { usePrevious } from './usePrevious';\n", "import * as React from 'react';\n\nfunction usePrevious<T>(value: T) {\n  const ref = React.useRef({ value, previous: value });\n\n  // We compare values before making an update to ensure that\n  // a change has been made. This ensures the previous value is\n  // persisted correctly between renders.\n  return React.useMemo(() => {\n    if (ref.current.value !== value) {\n      ref.current.previous = ref.current.value;\n      ref.current.value = value;\n    }\n    return ref.current.previous;\n  }, [value]);\n}\n\nexport { usePrevious };\n", "export {\n  VisuallyHidden,\n  //\n  Root,\n} from './VisuallyHidden';\nexport type { VisuallyHiddenProps } from './VisuallyHidden';\n", "import * as React from 'react';\nimport { Primitive } from '@radix-ui/react-primitive';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\n/* -------------------------------------------------------------------------------------------------\n * VisuallyHidden\n * -----------------------------------------------------------------------------------------------*/\n\nconst NAME = 'VisuallyHidden';\n\ntype VisuallyHiddenElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface VisuallyHiddenProps extends PrimitiveSpanProps {}\n\nconst VisuallyHidden = React.forwardRef<VisuallyHiddenElement, VisuallyHiddenProps>(\n  (props, forwardedRef) => {\n    return (\n      <Primitive.span\n        {...props}\n        ref={forwardedRef}\n        style={{\n          // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss\n          position: 'absolute',\n          border: 0,\n          width: 1,\n          height: 1,\n          padding: 0,\n          margin: -1,\n          overflow: 'hidden',\n          clip: 'rect(0, 0, 0, 0)',\n          whiteSpace: 'nowrap',\n          wordWrap: 'normal',\n          ...props.style,\n        }}\n      />\n    );\n  }\n);\n\nVisuallyHidden.displayName = NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = VisuallyHidden;\n\nexport {\n  VisuallyHidden,\n  //\n  Root,\n};\nexport type { VisuallyHiddenProps };\n", "export {\n  createNavigationMenuScope,\n  //\n  NavigationMenu,\n  NavigationMenuSub,\n  NavigationMenuList,\n  NavigationMenuItem,\n  NavigationMenuTrigger,\n  NavigationMenuLink,\n  NavigationMenuIndicator,\n  NavigationMenuContent,\n  NavigationMenuViewport,\n  //\n  Root,\n  Sub,\n  List,\n  Item,\n  Trigger,\n  Link,\n  Indicator,\n  Content,\n  Viewport,\n} from './NavigationMenu';\nexport type {\n  NavigationMenuProps,\n  NavigationMenuSubProps,\n  NavigationMenuListProps,\n  NavigationMenuItemProps,\n  NavigationMenuTriggerProps,\n  NavigationMenuLinkProps,\n  NavigationMenuIndicatorProps,\n  NavigationMenuContentProps,\n  NavigationMenuViewportProps,\n} from './NavigationMenu';\n", "/// <reference types=\"resize-observer-browser\" />\n\nimport * as React from 'react';\nimport ReactDOM from 'react-dom';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { composeRefs, useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useDirection } from '@radix-ui/react-direction';\nimport { Presence } from '@radix-ui/react-presence';\nimport { useId } from '@radix-ui/react-id';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { DismissableLayer } from '@radix-ui/react-dismissable-layer';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport * as VisuallyHiddenPrimitive from '@radix-ui/react-visually-hidden';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Orientation = 'vertical' | 'horizontal';\ntype Direction = 'ltr' | 'rtl';\n\n/* -------------------------------------------------------------------------------------------------\n * NavigationMenu\n * -----------------------------------------------------------------------------------------------*/\n\nconst NAVIGATION_MENU_NAME = 'NavigationMenu';\n\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  NavigationMenuTriggerElement,\n  { value: string }\n>(NAVIGATION_MENU_NAME);\n\nconst [FocusGroupCollection, useFocusGroupCollection, createFocusGroupCollectionScope] =\n  createCollection<FocusGroupItemElement, {}>(NAVIGATION_MENU_NAME);\n\ntype ScopedProps<P> = P & { __scopeNavigationMenu?: Scope };\nconst [createNavigationMenuContext, createNavigationMenuScope] = createContextScope(\n  NAVIGATION_MENU_NAME,\n  [createCollectionScope, createFocusGroupCollectionScope]\n);\n\ntype ContentData = {\n  ref?: React.Ref<ViewportContentMounterElement>;\n} & ViewportContentMounterProps;\n\ntype NavigationMenuContextValue = {\n  isRootMenu: boolean;\n  value: string;\n  previousValue: string;\n  baseId: string;\n  dir: Direction;\n  orientation: Orientation;\n  rootNavigationMenu: NavigationMenuElement | null;\n  indicatorTrack: HTMLDivElement | null;\n  onIndicatorTrackChange(indicatorTrack: HTMLDivElement | null): void;\n  viewport: NavigationMenuViewportElement | null;\n  onViewportChange(viewport: NavigationMenuViewportElement | null): void;\n  onViewportContentChange(contentValue: string, contentData: ContentData): void;\n  onViewportContentRemove(contentValue: string): void;\n  onTriggerEnter(itemValue: string): void;\n  onTriggerLeave(): void;\n  onContentEnter(): void;\n  onContentLeave(): void;\n  onItemSelect(itemValue: string): void;\n  onItemDismiss(): void;\n};\n\nconst [NavigationMenuProviderImpl, useNavigationMenuContext] =\n  createNavigationMenuContext<NavigationMenuContextValue>(NAVIGATION_MENU_NAME);\n\nconst [ViewportContentProvider, useViewportContentContext] = createNavigationMenuContext<{\n  items: Map<string, ContentData>;\n}>(NAVIGATION_MENU_NAME);\n\ntype NavigationMenuElement = React.ElementRef<typeof Primitive.nav>;\ntype PrimitiveNavProps = Radix.ComponentPropsWithoutRef<typeof Primitive.nav>;\ninterface NavigationMenuProps\n  extends Omit<NavigationMenuProviderProps, keyof NavigationMenuProviderPrivateProps>,\n    PrimitiveNavProps {\n  value?: string;\n  defaultValue?: string;\n  onValueChange?: (value: string) => void;\n  dir?: Direction;\n  orientation?: Orientation;\n  /**\n   * The duration from when the pointer enters the trigger until the tooltip gets opened.\n   * @defaultValue 200\n   */\n  delayDuration?: number;\n  /**\n   * How much time a user has to enter another trigger without incurring a delay again.\n   * @defaultValue 300\n   */\n  skipDelayDuration?: number;\n}\n\nconst NavigationMenu = React.forwardRef<NavigationMenuElement, NavigationMenuProps>(\n  (props: ScopedProps<NavigationMenuProps>, forwardedRef) => {\n    const {\n      __scopeNavigationMenu,\n      value: valueProp,\n      onValueChange,\n      defaultValue,\n      delayDuration = 200,\n      skipDelayDuration = 300,\n      orientation = 'horizontal',\n      dir,\n      ...NavigationMenuProps\n    } = props;\n    const [navigationMenu, setNavigationMenu] = React.useState<NavigationMenuElement | null>(null);\n    const composedRef = useComposedRefs(forwardedRef, (node) => setNavigationMenu(node));\n    const direction = useDirection(dir);\n    const openTimerRef = React.useRef(0);\n    const closeTimerRef = React.useRef(0);\n    const skipDelayTimerRef = React.useRef(0);\n    const [isOpenDelayed, setIsOpenDelayed] = React.useState(true);\n    const [value = '', setValue] = useControllableState({\n      prop: valueProp,\n      onChange: (value) => {\n        const isOpen = value !== '';\n        const hasSkipDelayDuration = skipDelayDuration > 0;\n\n        if (isOpen) {\n          window.clearTimeout(skipDelayTimerRef.current);\n          if (hasSkipDelayDuration) setIsOpenDelayed(false);\n        } else {\n          window.clearTimeout(skipDelayTimerRef.current);\n          skipDelayTimerRef.current = window.setTimeout(\n            () => setIsOpenDelayed(true),\n            skipDelayDuration\n          );\n        }\n\n        onValueChange?.(value);\n      },\n      defaultProp: defaultValue,\n    });\n\n    const startCloseTimer = React.useCallback(() => {\n      window.clearTimeout(closeTimerRef.current);\n      closeTimerRef.current = window.setTimeout(() => setValue(''), 150);\n    }, [setValue]);\n\n    const handleOpen = React.useCallback(\n      (itemValue: string) => {\n        window.clearTimeout(closeTimerRef.current);\n        setValue(itemValue);\n      },\n      [setValue]\n    );\n\n    const handleDelayedOpen = React.useCallback(\n      (itemValue: string) => {\n        const isOpenItem = value === itemValue;\n        if (isOpenItem) {\n          // If the item is already open (e.g. we're transitioning from the content to the trigger)\n          // then we want to clear the close timer immediately.\n          window.clearTimeout(closeTimerRef.current);\n        } else {\n          openTimerRef.current = window.setTimeout(() => {\n            window.clearTimeout(closeTimerRef.current);\n            setValue(itemValue);\n          }, delayDuration);\n        }\n      },\n      [value, setValue, delayDuration]\n    );\n\n    React.useEffect(() => {\n      return () => {\n        window.clearTimeout(openTimerRef.current);\n        window.clearTimeout(closeTimerRef.current);\n        window.clearTimeout(skipDelayTimerRef.current);\n      };\n    }, []);\n\n    return (\n      <NavigationMenuProvider\n        scope={__scopeNavigationMenu}\n        isRootMenu={true}\n        value={value}\n        dir={direction}\n        orientation={orientation}\n        rootNavigationMenu={navigationMenu}\n        onTriggerEnter={(itemValue) => {\n          window.clearTimeout(openTimerRef.current);\n          if (isOpenDelayed) handleDelayedOpen(itemValue);\n          else handleOpen(itemValue);\n        }}\n        onTriggerLeave={() => {\n          window.clearTimeout(openTimerRef.current);\n          startCloseTimer();\n        }}\n        onContentEnter={() => window.clearTimeout(closeTimerRef.current)}\n        onContentLeave={startCloseTimer}\n        onItemSelect={(itemValue) => {\n          setValue((prevValue) => (prevValue === itemValue ? '' : itemValue));\n        }}\n        onItemDismiss={() => setValue('')}\n      >\n        <Primitive.nav\n          aria-label=\"Main\"\n          data-orientation={orientation}\n          dir={direction}\n          {...NavigationMenuProps}\n          ref={composedRef}\n        />\n      </NavigationMenuProvider>\n    );\n  }\n);\n\nNavigationMenu.displayName = NAVIGATION_MENU_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * NavigationMenuSub\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_NAME = 'NavigationMenuSub';\n\ntype NavigationMenuSubElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface NavigationMenuSubProps\n  extends Omit<NavigationMenuProviderProps, keyof NavigationMenuProviderPrivateProps>,\n    PrimitiveDivProps {\n  value?: string;\n  defaultValue?: string;\n  onValueChange?: (value: string) => void;\n  orientation?: Orientation;\n}\n\nconst NavigationMenuSub = React.forwardRef<NavigationMenuSubElement, NavigationMenuSubProps>(\n  (props: ScopedProps<NavigationMenuSubProps>, forwardedRef) => {\n    const {\n      __scopeNavigationMenu,\n      value: valueProp,\n      onValueChange,\n      defaultValue,\n      orientation = 'horizontal',\n      ...subProps\n    } = props;\n    const context = useNavigationMenuContext(SUB_NAME, __scopeNavigationMenu);\n    const [value = '', setValue] = useControllableState({\n      prop: valueProp,\n      onChange: onValueChange,\n      defaultProp: defaultValue,\n    });\n\n    return (\n      <NavigationMenuProvider\n        scope={__scopeNavigationMenu}\n        isRootMenu={false}\n        value={value}\n        dir={context.dir}\n        orientation={orientation}\n        rootNavigationMenu={context.rootNavigationMenu}\n        onTriggerEnter={(itemValue) => setValue(itemValue)}\n        onItemSelect={(itemValue) => setValue(itemValue)}\n        onItemDismiss={() => setValue('')}\n      >\n        <Primitive.div data-orientation={orientation} {...subProps} ref={forwardedRef} />\n      </NavigationMenuProvider>\n    );\n  }\n);\n\nNavigationMenuSub.displayName = SUB_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ninterface NavigationMenuProviderPrivateProps {\n  isRootMenu: boolean;\n  scope: Scope;\n  children: React.ReactNode;\n  orientation: Orientation;\n  dir: Direction;\n  rootNavigationMenu: NavigationMenuElement | null;\n  value: string;\n  onTriggerEnter(itemValue: string): void;\n  onTriggerLeave?(): void;\n  onContentEnter?(): void;\n  onContentLeave?(): void;\n  onItemSelect(itemValue: string): void;\n  onItemDismiss(): void;\n}\n\ninterface NavigationMenuProviderProps extends NavigationMenuProviderPrivateProps {}\n\nconst NavigationMenuProvider: React.FC<NavigationMenuProviderProps> = (\n  props: ScopedProps<NavigationMenuProviderProps>\n) => {\n  const {\n    scope,\n    isRootMenu,\n    rootNavigationMenu,\n    dir,\n    orientation,\n    children,\n    value,\n    onItemSelect,\n    onItemDismiss,\n    onTriggerEnter,\n    onTriggerLeave,\n    onContentEnter,\n    onContentLeave,\n  } = props;\n  const [viewport, setViewport] = React.useState<NavigationMenuViewportElement | null>(null);\n  const [viewportContent, setViewportContent] = React.useState<Map<string, ContentData>>(new Map());\n  const [indicatorTrack, setIndicatorTrack] = React.useState<HTMLDivElement | null>(null);\n\n  return (\n    <NavigationMenuProviderImpl\n      scope={scope}\n      isRootMenu={isRootMenu}\n      rootNavigationMenu={rootNavigationMenu}\n      value={value}\n      previousValue={usePrevious(value)}\n      baseId={useId()}\n      dir={dir}\n      orientation={orientation}\n      viewport={viewport}\n      onViewportChange={setViewport}\n      indicatorTrack={indicatorTrack}\n      onIndicatorTrackChange={setIndicatorTrack}\n      onTriggerEnter={useCallbackRef(onTriggerEnter)}\n      onTriggerLeave={useCallbackRef(onTriggerLeave)}\n      onContentEnter={useCallbackRef(onContentEnter)}\n      onContentLeave={useCallbackRef(onContentLeave)}\n      onItemSelect={useCallbackRef(onItemSelect)}\n      onItemDismiss={useCallbackRef(onItemDismiss)}\n      onViewportContentChange={React.useCallback((contentValue, contentData) => {\n        setViewportContent((prevContent) => {\n          prevContent.set(contentValue, contentData);\n          return new Map(prevContent);\n        });\n      }, [])}\n      onViewportContentRemove={React.useCallback((contentValue) => {\n        setViewportContent((prevContent) => {\n          if (!prevContent.has(contentValue)) return prevContent;\n          prevContent.delete(contentValue);\n          return new Map(prevContent);\n        });\n      }, [])}\n    >\n      <Collection.Provider scope={scope}>\n        <ViewportContentProvider scope={scope} items={viewportContent}>\n          {children}\n        </ViewportContentProvider>\n      </Collection.Provider>\n    </NavigationMenuProviderImpl>\n  );\n};\n\n/* -------------------------------------------------------------------------------------------------\n * NavigationMenuList\n * -----------------------------------------------------------------------------------------------*/\n\nconst LIST_NAME = 'NavigationMenuList';\n\ntype NavigationMenuListElement = React.ElementRef<typeof Primitive.ul>;\ntype PrimitiveUnorderedListProps = Radix.ComponentPropsWithoutRef<typeof Primitive.ul>;\ninterface NavigationMenuListProps extends PrimitiveUnorderedListProps {}\n\nconst NavigationMenuList = React.forwardRef<NavigationMenuListElement, NavigationMenuListProps>(\n  (props: ScopedProps<NavigationMenuListProps>, forwardedRef) => {\n    const { __scopeNavigationMenu, ...listProps } = props;\n    const context = useNavigationMenuContext(LIST_NAME, __scopeNavigationMenu);\n\n    const list = (\n      <Primitive.ul data-orientation={context.orientation} {...listProps} ref={forwardedRef} />\n    );\n\n    return (\n      <Primitive.div style={{ position: 'relative' }} ref={context.onIndicatorTrackChange}>\n        <Collection.Slot scope={__scopeNavigationMenu}>\n          {context.isRootMenu ? <FocusGroup asChild>{list}</FocusGroup> : list}\n        </Collection.Slot>\n      </Primitive.div>\n    );\n  }\n);\n\nNavigationMenuList.displayName = LIST_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * NavigationMenuItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'NavigationMenuItem';\n\ntype FocusProxyElement = React.ElementRef<typeof VisuallyHiddenPrimitive.Root>;\n\ntype NavigationMenuItemContextValue = {\n  value: string;\n  triggerRef: React.RefObject<NavigationMenuTriggerElement>;\n  contentRef: React.RefObject<NavigationMenuContentElement>;\n  focusProxyRef: React.RefObject<FocusProxyElement>;\n  wasEscapeCloseRef: React.MutableRefObject<boolean>;\n  onEntryKeyDown(): void;\n  onFocusProxyEnter(side: 'start' | 'end'): void;\n  onRootContentClose(): void;\n  onContentFocusOutside(): void;\n};\n\nconst [NavigationMenuItemContextProvider, useNavigationMenuItemContext] =\n  createNavigationMenuContext<NavigationMenuItemContextValue>(ITEM_NAME);\n\ntype NavigationMenuItemElement = React.ElementRef<typeof Primitive.li>;\ntype PrimitiveListItemProps = Radix.ComponentPropsWithoutRef<typeof Primitive.li>;\ninterface NavigationMenuItemProps extends PrimitiveListItemProps {\n  value?: string;\n}\n\nconst NavigationMenuItem = React.forwardRef<NavigationMenuItemElement, NavigationMenuItemProps>(\n  (props: ScopedProps<NavigationMenuItemProps>, forwardedRef) => {\n    const { __scopeNavigationMenu, value: valueProp, ...itemProps } = props;\n    const autoValue = useId();\n    // We need to provide an initial deterministic value as `useId` will return\n    // empty string on the first render and we don't want to match our internal \"closed\" value.\n    const value = valueProp || autoValue || 'LEGACY_REACT_AUTO_VALUE';\n    const contentRef = React.useRef<NavigationMenuContentElement>(null);\n    const triggerRef = React.useRef<NavigationMenuTriggerElement>(null);\n    const focusProxyRef = React.useRef<FocusProxyElement>(null);\n    const restoreContentTabOrderRef = React.useRef(() => {});\n    const wasEscapeCloseRef = React.useRef(false);\n\n    const handleContentEntry = React.useCallback((side = 'start') => {\n      if (contentRef.current) {\n        restoreContentTabOrderRef.current();\n        const candidates = getTabbableCandidates(contentRef.current);\n        if (candidates.length) focusFirst(side === 'start' ? candidates : candidates.reverse());\n      }\n    }, []);\n\n    const handleContentExit = React.useCallback(() => {\n      if (contentRef.current) {\n        const candidates = getTabbableCandidates(contentRef.current);\n        if (candidates.length) restoreContentTabOrderRef.current = removeFromTabOrder(candidates);\n      }\n    }, []);\n\n    return (\n      <NavigationMenuItemContextProvider\n        scope={__scopeNavigationMenu}\n        value={value}\n        triggerRef={triggerRef}\n        contentRef={contentRef}\n        focusProxyRef={focusProxyRef}\n        wasEscapeCloseRef={wasEscapeCloseRef}\n        onEntryKeyDown={handleContentEntry}\n        onFocusProxyEnter={handleContentEntry}\n        onRootContentClose={handleContentExit}\n        onContentFocusOutside={handleContentExit}\n      >\n        <Primitive.li {...itemProps} ref={forwardedRef} />\n      </NavigationMenuItemContextProvider>\n    );\n  }\n);\n\nNavigationMenuItem.displayName = ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * NavigationMenuTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'NavigationMenuTrigger';\n\ntype NavigationMenuTriggerElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = Radix.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface NavigationMenuTriggerProps extends PrimitiveButtonProps {}\n\nconst NavigationMenuTrigger = React.forwardRef<\n  NavigationMenuTriggerElement,\n  NavigationMenuTriggerProps\n>((props: ScopedProps<NavigationMenuTriggerProps>, forwardedRef) => {\n  const { __scopeNavigationMenu, disabled, ...triggerProps } = props;\n  const context = useNavigationMenuContext(TRIGGER_NAME, props.__scopeNavigationMenu);\n  const itemContext = useNavigationMenuItemContext(TRIGGER_NAME, props.__scopeNavigationMenu);\n  const ref = React.useRef<NavigationMenuTriggerElement>(null);\n  const composedRefs = useComposedRefs(ref, itemContext.triggerRef, forwardedRef);\n  const triggerId = makeTriggerId(context.baseId, itemContext.value);\n  const contentId = makeContentId(context.baseId, itemContext.value);\n  const hasPointerMoveOpenedRef = React.useRef(false);\n  const wasClickCloseRef = React.useRef(false);\n  const open = itemContext.value === context.value;\n\n  return (\n    <>\n      <Collection.ItemSlot scope={__scopeNavigationMenu} value={itemContext.value}>\n        <FocusGroupItem asChild>\n          <Primitive.button\n            id={triggerId}\n            disabled={disabled}\n            data-disabled={disabled ? '' : undefined}\n            data-state={getOpenState(open)}\n            aria-expanded={open}\n            aria-controls={contentId}\n            {...triggerProps}\n            ref={composedRefs}\n            onPointerEnter={composeEventHandlers(props.onPointerEnter, () => {\n              wasClickCloseRef.current = false;\n              itemContext.wasEscapeCloseRef.current = false;\n            })}\n            onPointerMove={composeEventHandlers(\n              props.onPointerMove,\n              whenMouse(() => {\n                if (\n                  disabled ||\n                  wasClickCloseRef.current ||\n                  itemContext.wasEscapeCloseRef.current ||\n                  hasPointerMoveOpenedRef.current\n                )\n                  return;\n                context.onTriggerEnter(itemContext.value);\n                hasPointerMoveOpenedRef.current = true;\n              })\n            )}\n            onPointerLeave={composeEventHandlers(\n              props.onPointerLeave,\n              whenMouse(() => {\n                if (disabled) return;\n                context.onTriggerLeave();\n                hasPointerMoveOpenedRef.current = false;\n              })\n            )}\n            onClick={composeEventHandlers(props.onClick, () => {\n              context.onItemSelect(itemContext.value);\n              wasClickCloseRef.current = open;\n            })}\n            onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n              const verticalEntryKey = context.dir === 'rtl' ? 'ArrowLeft' : 'ArrowRight';\n              const entryKey = { horizontal: 'ArrowDown', vertical: verticalEntryKey }[\n                context.orientation\n              ];\n              if (open && event.key === entryKey) {\n                itemContext.onEntryKeyDown();\n                // Prevent FocusGroupItem from handling the event\n                event.preventDefault();\n              }\n            })}\n          />\n        </FocusGroupItem>\n      </Collection.ItemSlot>\n\n      {/* Proxy tab order between trigger and content */}\n      {open && (\n        <>\n          <VisuallyHiddenPrimitive.Root\n            aria-hidden\n            tabIndex={0}\n            ref={itemContext.focusProxyRef}\n            onFocus={(event) => {\n              const content = itemContext.contentRef.current;\n              const prevFocusedElement = event.relatedTarget as HTMLElement | null;\n              const wasTriggerFocused = prevFocusedElement === ref.current;\n              const wasFocusFromContent = content?.contains(prevFocusedElement);\n\n              if (wasTriggerFocused || !wasFocusFromContent) {\n                itemContext.onFocusProxyEnter(wasTriggerFocused ? 'start' : 'end');\n              }\n            }}\n          />\n\n          {/* Restructure a11y tree to make content accessible to screen reader when using the viewport */}\n          {context.viewport && <span aria-owns={contentId} />}\n        </>\n      )}\n    </>\n  );\n});\n\nNavigationMenuTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * NavigationMenuLink\n * -----------------------------------------------------------------------------------------------*/\n\nconst LINK_NAME = 'NavigationMenuLink';\nconst LINK_SELECT = 'navigationMenu.linkSelect';\n\ntype NavigationMenuLinkElement = React.ElementRef<typeof Primitive.a>;\ntype PrimitiveLinkProps = Radix.ComponentPropsWithoutRef<typeof Primitive.a>;\ninterface NavigationMenuLinkProps extends Omit<PrimitiveLinkProps, 'onSelect'> {\n  active?: boolean;\n  onSelect?: (event: Event) => void;\n}\n\nconst NavigationMenuLink = React.forwardRef<NavigationMenuLinkElement, NavigationMenuLinkProps>(\n  (props: ScopedProps<NavigationMenuLinkProps>, forwardedRef) => {\n    const { __scopeNavigationMenu, active, onSelect, ...linkProps } = props;\n\n    return (\n      <FocusGroupItem asChild>\n        <Primitive.a\n          data-active={active ? '' : undefined}\n          aria-current={active ? 'page' : undefined}\n          {...linkProps}\n          ref={forwardedRef}\n          onClick={composeEventHandlers(\n            props.onClick,\n            (event) => {\n              const target = event.target as HTMLElement;\n              const linkSelectEvent = new CustomEvent(LINK_SELECT, {\n                bubbles: true,\n                cancelable: true,\n              });\n              target.addEventListener(LINK_SELECT, (event) => onSelect?.(event), { once: true });\n              dispatchDiscreteCustomEvent(target, linkSelectEvent);\n\n              if (!linkSelectEvent.defaultPrevented && !event.metaKey) {\n                const rootContentDismissEvent = new CustomEvent(ROOT_CONTENT_DISMISS, {\n                  bubbles: true,\n                  cancelable: true,\n                });\n                dispatchDiscreteCustomEvent(target, rootContentDismissEvent);\n              }\n            },\n            { checkForDefaultPrevented: false }\n          )}\n        />\n      </FocusGroupItem>\n    );\n  }\n);\n\nNavigationMenuLink.displayName = LINK_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * NavigationMenuIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst INDICATOR_NAME = 'NavigationMenuIndicator';\n\ntype NavigationMenuIndicatorElement = NavigationMenuIndicatorImplElement;\ninterface NavigationMenuIndicatorProps extends NavigationMenuIndicatorImplProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst NavigationMenuIndicator = React.forwardRef<\n  NavigationMenuIndicatorElement,\n  NavigationMenuIndicatorProps\n>((props: ScopedProps<NavigationMenuIndicatorProps>, forwardedRef) => {\n  const { forceMount, ...indicatorProps } = props;\n  const context = useNavigationMenuContext(INDICATOR_NAME, props.__scopeNavigationMenu);\n  const isVisible = Boolean(context.value);\n\n  return context.indicatorTrack\n    ? ReactDOM.createPortal(\n        <Presence present={forceMount || isVisible}>\n          <NavigationMenuIndicatorImpl {...indicatorProps} ref={forwardedRef} />\n        </Presence>,\n        context.indicatorTrack\n      )\n    : null;\n});\n\nNavigationMenuIndicator.displayName = INDICATOR_NAME;\n\ntype NavigationMenuIndicatorImplElement = React.ElementRef<typeof Primitive.div>;\ninterface NavigationMenuIndicatorImplProps extends PrimitiveDivProps {}\n\nconst NavigationMenuIndicatorImpl = React.forwardRef<\n  NavigationMenuIndicatorImplElement,\n  NavigationMenuIndicatorImplProps\n>((props: ScopedProps<NavigationMenuIndicatorImplProps>, forwardedRef) => {\n  const { __scopeNavigationMenu, ...indicatorProps } = props;\n  const context = useNavigationMenuContext(INDICATOR_NAME, __scopeNavigationMenu);\n  const getItems = useCollection(__scopeNavigationMenu);\n  const [activeTrigger, setActiveTrigger] = React.useState<NavigationMenuTriggerElement | null>(\n    null\n  );\n  const [position, setPosition] = React.useState<{ size: number; offset: number } | null>(null);\n  const isHorizontal = context.orientation === 'horizontal';\n  const isVisible = Boolean(context.value);\n\n  React.useEffect(() => {\n    const items = getItems();\n    const triggerNode = items.find((item) => item.value === context.value)?.ref.current;\n    if (triggerNode) setActiveTrigger(triggerNode);\n  }, [getItems, context.value]);\n\n  /**\n   * Update position when the indicator or parent track size changes\n   */\n  const handlePositionChange = () => {\n    if (activeTrigger) {\n      setPosition({\n        size: isHorizontal ? activeTrigger.offsetWidth : activeTrigger.offsetHeight,\n        offset: isHorizontal ? activeTrigger.offsetLeft : activeTrigger.offsetTop,\n      });\n    }\n  };\n  useResizeObserver(activeTrigger, handlePositionChange);\n  useResizeObserver(context.indicatorTrack, handlePositionChange);\n\n  // We need to wait for the indicator position to be available before rendering to\n  // snap immediately into position rather than transitioning from initial\n  return position ? (\n    <Primitive.div\n      aria-hidden\n      data-state={isVisible ? 'visible' : 'hidden'}\n      data-orientation={context.orientation}\n      {...indicatorProps}\n      ref={forwardedRef}\n      style={{\n        position: 'absolute',\n        ...(isHorizontal\n          ? {\n              left: 0,\n              width: position.size + 'px',\n              transform: `translateX(${position.offset}px)`,\n            }\n          : {\n              top: 0,\n              height: position.size + 'px',\n              transform: `translateY(${position.offset}px)`,\n            }),\n        ...indicatorProps.style,\n      }}\n    />\n  ) : null;\n});\n\n/* -------------------------------------------------------------------------------------------------\n * NavigationMenuContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'NavigationMenuContent';\n\ntype NavigationMenuContentElement = NavigationMenuContentImplElement;\ninterface NavigationMenuContentProps\n  extends Omit<NavigationMenuContentImplProps, keyof NavigationMenuContentImplPrivateProps> {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst NavigationMenuContent = React.forwardRef<\n  NavigationMenuContentElement,\n  NavigationMenuContentProps\n>((props: ScopedProps<NavigationMenuContentProps>, forwardedRef) => {\n  const { forceMount, ...contentProps } = props;\n  const context = useNavigationMenuContext(CONTENT_NAME, props.__scopeNavigationMenu);\n  const itemContext = useNavigationMenuItemContext(CONTENT_NAME, props.__scopeNavigationMenu);\n  const composedRefs = useComposedRefs(itemContext.contentRef, forwardedRef);\n  const open = itemContext.value === context.value;\n\n  const commonProps = {\n    value: itemContext.value,\n    triggerRef: itemContext.triggerRef,\n    focusProxyRef: itemContext.focusProxyRef,\n    wasEscapeCloseRef: itemContext.wasEscapeCloseRef,\n    onContentFocusOutside: itemContext.onContentFocusOutside,\n    onRootContentClose: itemContext.onRootContentClose,\n    ...contentProps,\n  };\n\n  return !context.viewport ? (\n    <Presence present={forceMount || open}>\n      <NavigationMenuContentImpl\n        data-state={getOpenState(open)}\n        {...commonProps}\n        ref={composedRefs}\n        onPointerEnter={composeEventHandlers(props.onPointerEnter, context.onContentEnter)}\n        onPointerLeave={composeEventHandlers(\n          props.onPointerLeave,\n          whenMouse(context.onContentLeave)\n        )}\n        style={{\n          // Prevent interaction when animating out\n          pointerEvents: !open && context.isRootMenu ? 'none' : undefined,\n          ...commonProps.style,\n        }}\n      />\n    </Presence>\n  ) : (\n    <ViewportContentMounter forceMount={forceMount} {...commonProps} ref={composedRefs} />\n  );\n});\n\nNavigationMenuContent.displayName = CONTENT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype ViewportContentMounterElement = NavigationMenuContentImplElement;\ninterface ViewportContentMounterProps extends NavigationMenuContentImplProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst ViewportContentMounter = React.forwardRef<\n  ViewportContentMounterElement,\n  ViewportContentMounterProps\n>((props: ScopedProps<ViewportContentMounterProps>, forwardedRef) => {\n  const context = useNavigationMenuContext(CONTENT_NAME, props.__scopeNavigationMenu);\n  const { onViewportContentChange, onViewportContentRemove } = context;\n\n  useLayoutEffect(() => {\n    onViewportContentChange(props.value, {\n      ref: forwardedRef,\n      ...props,\n    });\n  }, [props, forwardedRef, onViewportContentChange]);\n\n  useLayoutEffect(() => {\n    return () => onViewportContentRemove(props.value);\n  }, [props.value, onViewportContentRemove]);\n\n  // Content is proxied into the viewport\n  return null;\n});\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst ROOT_CONTENT_DISMISS = 'navigationMenu.rootContentDismiss';\n\ntype MotionAttribute = 'to-start' | 'to-end' | 'from-start' | 'from-end';\ntype NavigationMenuContentImplElement = React.ElementRef<typeof DismissableLayer>;\ntype DismissableLayerProps = Radix.ComponentPropsWithoutRef<typeof DismissableLayer>;\n\ninterface NavigationMenuContentImplPrivateProps {\n  value: string;\n  triggerRef: React.RefObject<NavigationMenuTriggerElement>;\n  focusProxyRef: React.RefObject<FocusProxyElement>;\n  wasEscapeCloseRef: React.MutableRefObject<boolean>;\n  onContentFocusOutside(): void;\n  onRootContentClose(): void;\n}\ninterface NavigationMenuContentImplProps\n  extends Omit<DismissableLayerProps, 'onDismiss'>,\n    NavigationMenuContentImplPrivateProps {}\n\nconst NavigationMenuContentImpl = React.forwardRef<\n  NavigationMenuContentImplElement,\n  NavigationMenuContentImplProps\n>((props: ScopedProps<NavigationMenuContentImplProps>, forwardedRef) => {\n  const {\n    __scopeNavigationMenu,\n    value,\n    triggerRef,\n    focusProxyRef,\n    wasEscapeCloseRef,\n    onRootContentClose,\n    onContentFocusOutside,\n    ...contentProps\n  } = props;\n  const context = useNavigationMenuContext(CONTENT_NAME, __scopeNavigationMenu);\n  const ref = React.useRef<NavigationMenuContentImplElement>(null);\n  const composedRefs = useComposedRefs(ref, forwardedRef);\n  const triggerId = makeTriggerId(context.baseId, value);\n  const contentId = makeContentId(context.baseId, value);\n  const getItems = useCollection(__scopeNavigationMenu);\n  const prevMotionAttributeRef = React.useRef<MotionAttribute | null>(null);\n\n  const { onItemDismiss } = context;\n\n  React.useEffect(() => {\n    const content = ref.current;\n\n    // Bubble dismiss to the root content node and focus its trigger\n    if (context.isRootMenu && content) {\n      const handleClose = () => {\n        onItemDismiss();\n        onRootContentClose();\n        if (content.contains(document.activeElement)) triggerRef.current?.focus();\n      };\n      content.addEventListener(ROOT_CONTENT_DISMISS, handleClose);\n      return () => content.removeEventListener(ROOT_CONTENT_DISMISS, handleClose);\n    }\n  }, [context.isRootMenu, props.value, triggerRef, onItemDismiss, onRootContentClose]);\n\n  const motionAttribute = React.useMemo(() => {\n    const items = getItems();\n    const values = items.map((item) => item.value);\n    if (context.dir === 'rtl') values.reverse();\n    const index = values.indexOf(context.value);\n    const prevIndex = values.indexOf(context.previousValue);\n    const isSelected = value === context.value;\n    const wasSelected = prevIndex === values.indexOf(value);\n\n    // We only want to update selected and the last selected content\n    // this avoids animations being interrupted outside of that range\n    if (!isSelected && !wasSelected) return prevMotionAttributeRef.current;\n\n    const attribute = (() => {\n      // Don't provide a direction on the initial open\n      if (index !== prevIndex) {\n        // If we're moving to this item from another\n        if (isSelected && prevIndex !== -1) return index > prevIndex ? 'from-end' : 'from-start';\n        // If we're leaving this item for another\n        if (wasSelected && index !== -1) return index > prevIndex ? 'to-start' : 'to-end';\n      }\n      // Otherwise we're entering from closed or leaving the list\n      // entirely and should not animate in any direction\n      return null;\n    })();\n\n    prevMotionAttributeRef.current = attribute;\n    return attribute;\n  }, [context.previousValue, context.value, context.dir, getItems, value]);\n\n  return (\n    <FocusGroup asChild>\n      <DismissableLayer\n        id={contentId}\n        aria-labelledby={triggerId}\n        data-motion={motionAttribute}\n        data-orientation={context.orientation}\n        {...contentProps}\n        ref={composedRefs}\n        onDismiss={() => {\n          const rootContentDismissEvent = new Event(ROOT_CONTENT_DISMISS, {\n            bubbles: true,\n            cancelable: true,\n          });\n          ref.current?.dispatchEvent(rootContentDismissEvent);\n        }}\n        onFocusOutside={composeEventHandlers(props.onFocusOutside, (event) => {\n          onContentFocusOutside();\n          const target = event.target as HTMLElement;\n          // Only dismiss content when focus moves outside of the menu\n          if (context.rootNavigationMenu?.contains(target)) event.preventDefault();\n        })}\n        onPointerDownOutside={composeEventHandlers(props.onPointerDownOutside, (event) => {\n          const target = event.target as HTMLElement;\n          const isTrigger = getItems().some((item) => item.ref.current?.contains(target));\n          const isRootViewport = context.isRootMenu && context.viewport?.contains(target);\n          if (isTrigger || isRootViewport || !context.isRootMenu) event.preventDefault();\n        })}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;\n          const isTabKey = event.key === 'Tab' && !isMetaKey;\n          if (isTabKey) {\n            const candidates = getTabbableCandidates(event.currentTarget);\n            const focusedElement = document.activeElement;\n            const index = candidates.findIndex((candidate) => candidate === focusedElement);\n            const isMovingBackwards = event.shiftKey;\n            const nextCandidates = isMovingBackwards\n              ? candidates.slice(0, index).reverse()\n              : candidates.slice(index + 1, candidates.length);\n\n            if (focusFirst(nextCandidates)) {\n              // prevent browser tab keydown because we've handled focus\n              event.preventDefault();\n            } else {\n              // If we can't focus that means we're at the edges\n              // so focus the proxy and let browser handle\n              // tab/shift+tab keypress on the proxy instead\n              focusProxyRef.current?.focus();\n            }\n          }\n        })}\n        onEscapeKeyDown={composeEventHandlers(props.onEscapeKeyDown, (event) => {\n          // prevent the dropdown from reopening\n          // after the escape key has been pressed\n          wasEscapeCloseRef.current = true;\n        })}\n      />\n    </FocusGroup>\n  );\n});\n\n/* -------------------------------------------------------------------------------------------------\n * NavigationMenuViewport\n * -----------------------------------------------------------------------------------------------*/\n\nconst VIEWPORT_NAME = 'NavigationMenuViewport';\n\ntype NavigationMenuViewportElement = NavigationMenuViewportImplElement;\ninterface NavigationMenuViewportProps\n  extends Omit<NavigationMenuViewportImplProps, 'children' | 'activeContentValue'> {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst NavigationMenuViewport = React.forwardRef<\n  NavigationMenuViewportElement,\n  NavigationMenuViewportProps\n>((props: ScopedProps<NavigationMenuViewportProps>, forwardedRef) => {\n  const { forceMount, ...viewportProps } = props;\n  const context = useNavigationMenuContext(VIEWPORT_NAME, props.__scopeNavigationMenu);\n  const open = Boolean(context.value);\n\n  return (\n    <Presence present={forceMount || open}>\n      <NavigationMenuViewportImpl {...viewportProps} ref={forwardedRef} />\n    </Presence>\n  );\n});\n\nNavigationMenuViewport.displayName = VIEWPORT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype NavigationMenuViewportImplElement = React.ElementRef<typeof Primitive.div>;\ninterface NavigationMenuViewportImplProps extends PrimitiveDivProps {}\n\nconst NavigationMenuViewportImpl = React.forwardRef<\n  NavigationMenuViewportImplElement,\n  NavigationMenuViewportImplProps\n>((props: ScopedProps<NavigationMenuViewportImplProps>, forwardedRef) => {\n  const { __scopeNavigationMenu, children, ...viewportImplProps } = props;\n  const context = useNavigationMenuContext(VIEWPORT_NAME, __scopeNavigationMenu);\n  const composedRefs = useComposedRefs(forwardedRef, context.onViewportChange);\n  const viewportContentContext = useViewportContentContext(\n    CONTENT_NAME,\n    props.__scopeNavigationMenu\n  );\n  const [size, setSize] = React.useState<{ width: number; height: number } | null>(null);\n  const [content, setContent] = React.useState<NavigationMenuContentElement | null>(null);\n  const viewportWidth = size ? size?.width + 'px' : undefined;\n  const viewportHeight = size ? size?.height + 'px' : undefined;\n  const open = Boolean(context.value);\n  // We persist the last active content value as the viewport may be animating out\n  // and we want the content to remain mounted for the lifecycle of the viewport.\n  const activeContentValue = open ? context.value : context.previousValue;\n\n  /**\n   * Update viewport size to match the active content node.\n   * We prefer offset dimensions over `getBoundingClientRect` as the latter respects CSS transform.\n   * For example, if content animates in from `scale(0.5)` the dimensions would be anything\n   * from `0.5` to `1` of the intended size.\n   */\n  const handleSizeChange = () => {\n    if (content) setSize({ width: content.offsetWidth, height: content.offsetHeight });\n  };\n  useResizeObserver(content, handleSizeChange);\n\n  return (\n    <Primitive.div\n      data-state={getOpenState(open)}\n      data-orientation={context.orientation}\n      {...viewportImplProps}\n      ref={composedRefs}\n      style={{\n        // Prevent interaction when animating out\n        pointerEvents: !open && context.isRootMenu ? 'none' : undefined,\n        ['--radix-navigation-menu-viewport-width' as any]: viewportWidth,\n        ['--radix-navigation-menu-viewport-height' as any]: viewportHeight,\n        ...viewportImplProps.style,\n      }}\n      onPointerEnter={composeEventHandlers(props.onPointerEnter, context.onContentEnter)}\n      onPointerLeave={composeEventHandlers(props.onPointerLeave, whenMouse(context.onContentLeave))}\n    >\n      {Array.from(viewportContentContext.items).map(([value, { ref, forceMount, ...props }]) => {\n        const isActive = activeContentValue === value;\n        return (\n          <Presence key={value} present={forceMount || isActive}>\n            <NavigationMenuContentImpl\n              {...props}\n              ref={composeRefs(ref, (node) => {\n                // We only want to update the stored node when another is available\n                // as we need to smoothly transition between them.\n                if (isActive && node) setContent(node);\n              })}\n            />\n          </Presence>\n        );\n      })}\n    </Primitive.div>\n  );\n});\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_GROUP_NAME = 'FocusGroup';\n\ntype FocusGroupElement = React.ElementRef<typeof Primitive.div>;\ninterface FocusGroupProps extends PrimitiveDivProps {}\n\nconst FocusGroup = React.forwardRef<FocusGroupElement, FocusGroupProps>(\n  (props: ScopedProps<FocusGroupProps>, forwardedRef) => {\n    const { __scopeNavigationMenu, ...groupProps } = props;\n    const context = useNavigationMenuContext(FOCUS_GROUP_NAME, __scopeNavigationMenu);\n\n    return (\n      <FocusGroupCollection.Provider scope={__scopeNavigationMenu}>\n        <FocusGroupCollection.Slot scope={__scopeNavigationMenu}>\n          <Primitive.div dir={context.dir} {...groupProps} ref={forwardedRef} />\n        </FocusGroupCollection.Slot>\n      </FocusGroupCollection.Provider>\n    );\n  }\n);\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_KEYS = ['ArrowRight', 'ArrowLeft', 'ArrowUp', 'ArrowDown'];\nconst FOCUS_GROUP_ITEM_NAME = 'FocusGroupItem';\n\ntype FocusGroupItemElement = React.ElementRef<typeof Primitive.button>;\ninterface FocusGroupItemProps extends PrimitiveButtonProps {}\n\nconst FocusGroupItem = React.forwardRef<FocusGroupItemElement, FocusGroupItemProps>(\n  (props: ScopedProps<FocusGroupItemProps>, forwardedRef) => {\n    const { __scopeNavigationMenu, ...groupProps } = props;\n    const getItems = useFocusGroupCollection(__scopeNavigationMenu);\n    const context = useNavigationMenuContext(FOCUS_GROUP_ITEM_NAME, __scopeNavigationMenu);\n\n    return (\n      <FocusGroupCollection.ItemSlot scope={__scopeNavigationMenu}>\n        <Primitive.button\n          {...groupProps}\n          ref={forwardedRef}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            const isFocusNavigationKey = ['Home', 'End', ...ARROW_KEYS].includes(event.key);\n            if (isFocusNavigationKey) {\n              let candidateNodes = getItems().map((item) => item.ref.current!);\n              const prevItemKey = context.dir === 'rtl' ? 'ArrowRight' : 'ArrowLeft';\n              const prevKeys = [prevItemKey, 'ArrowUp', 'End'];\n              if (prevKeys.includes(event.key)) candidateNodes.reverse();\n              if (ARROW_KEYS.includes(event.key)) {\n                const currentIndex = candidateNodes.indexOf(event.currentTarget);\n                candidateNodes = candidateNodes.slice(currentIndex + 1);\n              }\n              /**\n               * Imperative focus during keydown is risky so we prevent React's batching updates\n               * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n               */\n              setTimeout(() => focusFirst(candidateNodes));\n\n              // Prevent page scroll while navigating\n              event.preventDefault();\n            }\n          })}\n        />\n      </FocusGroupCollection.ItemSlot>\n    );\n  }\n);\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const previouslyFocusedElement = document.activeElement;\n  return candidates.some((candidate) => {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === previouslyFocusedElement) return true;\n    candidate.focus();\n    return document.activeElement !== previouslyFocusedElement;\n  });\n}\n\nfunction removeFromTabOrder(candidates: HTMLElement[]) {\n  candidates.forEach((candidate) => {\n    candidate.dataset.tabindex = candidate.getAttribute('tabindex') || '';\n    candidate.setAttribute('tabindex', '-1');\n  });\n  return () => {\n    candidates.forEach((candidate) => {\n      const prevTabIndex = candidate.dataset.tabindex as string;\n      candidate.setAttribute('tabindex', prevTabIndex);\n    });\n  };\n}\n\nfunction useResizeObserver(element: HTMLElement | null, onResize: () => void) {\n  const handleResize = useCallbackRef(onResize);\n  useLayoutEffect(() => {\n    let rAF = 0;\n    if (element) {\n      /**\n       * Resize Observer will throw an often benign error that says `ResizeObserver loop\n       * completed with undelivered notifications`. This means that ResizeObserver was not\n       * able to deliver all observations within a single animation frame, so we use\n       * `requestAnimationFrame` to ensure we don't deliver unnecessary observations.\n       * Further reading: https://github.com/WICG/resize-observer/issues/38\n       */\n      const resizeObserver = new ResizeObserver(() => {\n        cancelAnimationFrame(rAF);\n        rAF = window.requestAnimationFrame(handleResize);\n      });\n      resizeObserver.observe(element);\n      return () => {\n        window.cancelAnimationFrame(rAF);\n        resizeObserver.unobserve(element);\n      };\n    }\n  }, [element, handleResize]);\n}\n\nfunction getOpenState(open: boolean) {\n  return open ? 'open' : 'closed';\n}\n\nfunction makeTriggerId(baseId: string, value: string) {\n  return `${baseId}-trigger-${value}`;\n}\n\nfunction makeContentId(baseId: string, value: string) {\n  return `${baseId}-content-${value}`;\n}\n\nfunction whenMouse<E>(handler: React.PointerEventHandler<E>): React.PointerEventHandler<E> {\n  return (event) => (event.pointerType === 'mouse' ? handler(event) : undefined);\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = NavigationMenu;\nconst Sub = NavigationMenuSub;\nconst List = NavigationMenuList;\nconst Item = NavigationMenuItem;\nconst Trigger = NavigationMenuTrigger;\nconst Link = NavigationMenuLink;\nconst Indicator = NavigationMenuIndicator;\nconst Content = NavigationMenuContent;\nconst Viewport = NavigationMenuViewport;\n\nexport {\n  createNavigationMenuScope,\n  //\n  NavigationMenu,\n  NavigationMenuSub,\n  NavigationMenuList,\n  NavigationMenuItem,\n  NavigationMenuTrigger,\n  NavigationMenuLink,\n  NavigationMenuIndicator,\n  NavigationMenuContent,\n  NavigationMenuViewport,\n  //\n  Root,\n  Sub,\n  List,\n  Item,\n  Trigger,\n  Link,\n  Indicator,\n  Content,\n  Viewport,\n};\nexport type {\n  NavigationMenuProps,\n  NavigationMenuSubProps,\n  NavigationMenuListProps,\n  NavigationMenuItemProps,\n  NavigationMenuTriggerProps,\n  NavigationMenuLinkProps,\n  NavigationMenuIndicatorProps,\n  NavigationMenuContentProps,\n  NavigationMenuViewportProps,\n};\n"],
  "mappings": "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",
  "names": ["usePrevious", "value", "ref", "React", "previous", "current", "NAME", "VisuallyHidden", "React", "props", "forwardedRef", "$kVwnw$createElement", "position", "border", "width", "height", "padding", "margin", "overflow", "clip", "whiteSpace", "wordWrap", "style", "Root", "NAVIGATION_MENU_NAME", "Collection", "useCollection", "createCollectionScope", "createCollection", "FocusGroupCollection", "useFocusGroupCollection", "createFocusGroupCollectionScope", "createNavigationMenuContext", "createNavigationMenuScope", "createContextScope", "NavigationMenuProviderImpl", "useNavigationMenuContext", "ViewportContentProvider", "useViewportContentContext", "NavigationMenu", "React", "props", "forwardedRef", "value", "valueProp", "NavigationMenuProps", "navigationMenu", "setNavigationMenu", "composedRef", "useComposedRefs", "node", "direction", "useDirection", "dir", "openTimerRef", "closeTimerRef", "skipDelayTimerRef", "isOpenDelayed", "setIsOpenDelayed", "setValue", "useControllableState", "prop", "onChange", "isOpen", "hasSkipDelayDuration", "skipDelayDuration", "window", "clearTimeout", "current", "setTimeout", "onValueChange", "defaultProp", "defaultValue", "startCloseTimer", "handleOpen", "itemValue", "handleDelayedOpen", "isOpenItem", "delayDuration", "$yHMN2$createElement", "__scopeNavigationMenu", "prevValue", "orientation", "SUB_NAME", "NavigationMenuSub", "subProps", "context", "rootNavigationMenu", "NavigationMenuProvider", "onContentLeave", "viewport", "setViewport", "viewportContent", "setViewportContent", "Map", "indicatorTrack", "setIndicatorTrack", "usePrevious", "useId", "useCallbackRef", "onTriggerEnter", "onTriggerLeave", "onContentEnter", "onItemSelect", "onItemDismiss", "contentValue", "contentData", "prevContent", "set", "has", "delete", "children", "LIST_NAME", "NavigationMenuList", "listProps", "list", "position", "onIndicatorTrackChange", "isRootMenu", "ITEM_NAME", "NavigationMenuItemContextProvider", "useNavigationMenuItemContext", "NavigationMenuItem", "itemProps", "autoValue", "contentRef", "triggerRef", "focusProxyRef", "restoreContentTabOrderRef", "wasEscapeCloseRef", "handleContentEntry", "side", "candidates", "getTabbableCandidates", "length", "focusFirst", "reverse", "handleContentExit", "removeFromTabOrder", "TRIGGER_NAME", "NavigationMenuTrigger", "triggerProps", "itemContext", "ref", "composedRefs", "triggerId", "makeTriggerId", "baseId", "contentId", "makeContentId", "hasPointerMoveOpenedRef", "wasClickCloseRef", "open", "$yHMN2$Fragment", "disabled", "undefined", "getOpenState", "composeEventHandlers", "onPointerEnter", "onPointerMove", "whenMouse", "onPointerLeave", "onClick", "onKeyDown", "event", "verticalEntryKey", "entryKey", "horizontal", "vertical", "key", "onEntryKeyDown", "preventDefault", "content", "prevFocusedElement", "relatedTarget", "wasTriggerFocused", "wasFocusFromContent", "contains", "onFocusProxyEnter", "LINK_NAME", "LINK_SELECT", "NavigationMenuLink", "linkProps", "active", "target", "linkSelectEvent", "CustomEvent", "bubbles", "cancelable", "addEventListener", "onSelect", "once", "dispatchDiscreteCustomEvent", "defaultPrevented", "metaKey", "rootContentDismissEvent", "ROOT_CONTENT_DISMISS", "checkForDefaultPrevented", "INDICATOR_NAME", "NavigationMenuIndicator", "indicatorProps", "isVisible", "Boolean", "ReactDOM", "createPortal", "forceMount", "NavigationMenuIndicatorImpl", "getItems", "activeTrigger", "setActiveTrigger", "setPosition", "isHorizontal", "items", "triggerNode", "find", "item", "handlePositionChange", "size", "offsetWidth", "offsetHeight", "offset", "offsetLeft", "offsetTop", "useResizeObserver", "left", "width", "transform", "top", "height", "style", "CONTENT_NAME", "NavigationMenuContent", "contentProps", "commonProps", "onContentFocusOutside", "onRootContentClose", "pointerEvents", "ViewportContentMounter", "onViewportContentRemove", "useLayoutEffect", "onViewportContentChange", "NavigationMenuContentImpl", "prevMotionAttributeRef", "handleClose", "document", "activeElement", "focus", "removeEventListener", "motionAttribute", "values", "map", "index", "indexOf", "prevIndex", "previousValue", "isSelected", "wasSelected", "attribute", "Event", "dispatchEvent", "onFocusOutside", "onPointerDownOutside", "isTrigger", "some", "isRootViewport", "isMetaKey", "altKey", "ctrlKey", "isTabKey", "currentTarget", "focusedElement", "findIndex", "candidate", "isMovingBackwards", "shiftKey", "nextCandidates", "slice", "onEscapeKeyDown", "VIEWPORT_NAME", "NavigationMenuViewport", "viewportProps", "NavigationMenuViewportImpl", "viewportImplProps", "onViewportChange", "viewportContentContext", "setSize", "setContent", "viewportWidth", "viewportHeight", "activeContentValue", "handleSizeChange", "Array", "from", "isActive", "composeRefs", "FOCUS_GROUP_NAME", "FocusGroup", "groupProps", "ARROW_KEYS", "FOCUS_GROUP_ITEM_NAME", "FocusGroupItem", "isFocusNavigationKey", "includes", "candidateNodes", "prevItemKey", "prevKeys", "currentIndex", "container", "nodes", "walker", "createTreeWalker", "NodeFilter", "SHOW_ELEMENT", "acceptNode", "isHiddenInput", "tagName", "type", "hidden", "FILTER_SKIP", "tabIndex", "FILTER_ACCEPT", "nextNode", "push", "currentNode", "previouslyFocusedElement", "forEach", "dataset", "tabindex", "getAttribute", "setAttribute", "prevTabIndex", "element", "onResize", "handleResize", "rAF", "resizeObserver", "ResizeObserver", "cancelAnimationFrame", "requestAnimationFrame", "observe", "unobserve", "handler", "pointerType", "Root", "Sub", "List", "Item", "Trigger", "Link", "Indicator", "Content", "Viewport"]
}
